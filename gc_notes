- Garbage Collection: A form of automatic memory management.
	- Reclaim memory occupied by objects that are no longer in use
	- Fun fact: GC invented by John McCarthy (circa 1959) to simplify memory management in Lisp
- Terminology
	- block: A group of contiguous memory words
	- heap: The region of memory in which blocks reside
	- allocate: To set aside a block for use by a program (which returns a pointer to the block)
	- deallocate, free: To make an allocated block's memory available for future allocation
	- garbage block, garbage: A still-allocated block that hasn't yet been freed, but won't be used
	  further
- Allocation Algorithms
	- One Big Free Space
		- Uses block data structure
		- All in-use blocks at top of heap
		- Rest of heap is one free block
		- Pros
			- Non-fragmented free space
			- Simple and fast allocation
		- Cons
			- Compacting algorithm (slower)
				- Blocks must be shifted, pointers must be adjusted
	- Free List
		- Both in-use and unused blocks located anywhere in the heap
		- Free blocks are linked via a linked list
			- i.e., freeBlock1->next = freeBlock2, freeBlock2->next = freeBlock3, ...
		- Pros
			- Non-compacting
				- In-use blocks not shifted, no pointers adjusted
		- Cons
			- Complicated, slower allocation
			- Fragmented free-space
- Types
	- Tracing
		- Determines which objects are reachable from certain "root" objects
		- Collects those which are not and deallocates them
		- What is reachable?
			- A distinguished set of root objects
				- Objects referenced in the call stack
					- local vars and params
				- Any global vars
			- Anything referenced from a reachable object
	- Reference Counting
		- Tracks the number (count) of references held to it by other objects
			- Object becomes unreachable when reference count reaches zero
		- Pros
			- Non-compacting
			- Heap maintenance spread throughout program execution
				- Does not suspend program when GC runs
		- Cons
			- Extra word in block header to hold ref count
			- Fragile if reference counts are not adjusted upon any pointer assignment	
			- Cannot garbage collect circularly linked data structures
	- Mark and Sweep
		- Mark all blocks reachable from the root (tracing garbage collection)
			- This makes all unmarked blocks unreachable; they are garbage
		- Sweep unmarked blocks into free list (non-compacting)
		- Pros
			- Minimal overhead in block header
			- Heap maintenance not required on every pointer assignment
			- Can garbage collect circularly linked data structures
		- Cons
			- Heap fragmentation
	- Tri-color Marking
		- Three sets are created
			- White
				- "Condemned set"; set of garbage
			- Black
				- Objects which have no references to any objects in the white set
				- Objects which are reachable from the roots
			- Grey
				- Objects which are reachable from the roots, but have yet to be
				  scanned for references to objects in the white set
				- They are not garbage because they are reachable from the roots
					- They will end up in the black set after being scanned
- Implementation Strategies 
	- Moving (compacting)
		- Release unreachable objects and leave everything else as-is
		- No additional work required to reclaim free space
		- Usually, large, contiguous regions of memory are made available
			- Allows for simple allocation of new objects by merely incrementing a
			  free memory pointer
	- Non-moving (non-compacting)
		- Copy some or all of the reachable objects into a new area of memory and update
		  references to those objects as-needed
		- Must inspect each unreachable object and make note that the previously-occupied 
		  memory is now available
	- Generational GC (Ephemeral GC)
		- Based off of the idea that the most recently-created objects are the most likely
		  to become unreachable the fastest
	- Stop-the-world
		- Completely halt program execution to collect garbage
			- Ensures no objects are allocated or become unreachable during GC
		- Massive performance implications
		- Probably better for non-interactive programs
	- Incremental
		- Collection happens in discrete phases of program execution
			- Interleaved with program execution
	- Concurrent
		- Only stop program execution when the execution stack is examined
		- Also interleaved with program execution
- Frees the programmer from having to perform manual memory management
	- Eliminates:
		- Dangling pointers
		- Freeing an object twice
		- Failing to free objects before they become unreachable
			- e.g., freeing the head of a linked list before freeing the rest of the list
		- etc...
- GC does have performance implications
